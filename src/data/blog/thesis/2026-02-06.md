# Visualization With Claude Opus 4.6

Published: true
Pinned: true

## The Moment

Yesterday, Anthropic released Claude Opus 4.6. With it they also released a multi-agent workflow for Claude Code. This allows your Claude Code session to act as an orchestrator between `n` number of defined agents. More than just the subagents that Claude Code traditionally uses (as of the time of writing with Claude Code `v2.1.45`).

This has inspired me to accelerate the next step of the thesis. That is, adding some advanced visualization to the ppx ecosystem. To do so I will be writing a fun little prompt to have Claude create a React-based frontend and FastAPI backend, which is the stack I've been using quite extensively lately. I'll also set Claude up with a Shadcn MCP server (FE will use Shadcn with Radix) as well as specific `CLAUDE.md's`, `rules`, and `skills` relevant to my opinionated development methodologies. Let's see how Opus 4.6 and multi-agent orchestration does...

## The Setup

I had Claude in another instance create a <span data-pdf="/blog-assets/thesis/thesis.pdf">paper from my thesis notes</span>, poster, and codebase. I had it write it in LaTeX and I then rendered the PDF. It is in no way a real academic paper but Ken and I discussed how we might get better results from agentic coding tools (especially in long-running sessions) by using heavy mathematical language and academic language. Let's see if it helps Claude at all. I'll use the following prompt to have Claude create the system:

> Create an agent team of 4 agents. Each with a distinct role.
>
> 1. Architect: The team leader. The architect will orchestrate the building of the systems requirements. The architect will research gaps in the requirements and provide design specs to the team. The Architect will also create the DoD (definition of done) and acceptance criteria. The architect will ensure that the structural design matches the rules in the CLAUDE.md and references rule layers.
> 2. Backend: The backend agent will build the API based on the CLAUDE.md specs and technologies. The architect will pass the designs to the Backend Agent. They will be responsible to adhere to the specific rules and sections of CLAUDE.md relevant to the backend.
> 3. Frontend: The frontend agent will communicate with the backend agent to build the frontend of the system. It will follow similar patterns for React, Shadcn, Radix, Tailwind and Vite.
> 4. QA: The QA agent will be responsible to testing the system through automated scripts. They ensure that the acceptance criteria is met by the Architect.
>
> The goal is to build the API and frontend interfaces for the PPX system. Use the research_summary.tex paper as well as the CLI command tool to build out the API interface. Treat the PPX CLI as a low-level service that the API will use to do the most complex work. The API should offload requests through the frontend interface to a worker and queue system. In which the command will run (which may take a long time) and the user will know that they are waiting while the system queues the task and the worker picks it up once finished.
>
> The key user workflow is to upload a document, have PPX parse, align, and understand the document, and then allow the user to query the document. When the user queries the document they should see the PDF they uploaded on the left, and the Markdown on the right. Running a query will navigate the user to that specific location in the document (in both .md and the PDF) and highlight it. It will also allow them to switch (forward/backward navigate) to the next or previous result. The user should be able to see their previous upload history as well as their queries to the system.
>
> The frontend agent should evaluate image1.png and image2.png to gain a full understanding of the desired workflow. Do not copy the functionality observed exactly but please use it as a reference. This is how I want the alignment visual to look. On top of that I want to create the querying system that uses this alignment.
>
> Queries: The query should use the theorized Knowledge-Graph from the paper proposal to allow the user to ask a general question that does not explicitly mention text from the document but relates to similar concepts. For example, if I ask it "What is fruit", it should take me to a location in the document that writes about apples. Before implementing this feature we will focus on what currently exists in PPX. That is, alignment and basic semantic querying.
>
> The system should:
>
> - Port forward an address from SSH. i.e. I should be able to run the frontend on my local machine and connect to the API with my ssh credentials (as it is hosted on the server). This is to use the computer power of the server (4 v100 GPUs).
> - Have an engaging and modern frontend interface.
> - Follow all design guidelines made between the CLAUDE.md and rules/skills documents.
> - Use skills to build new sections of the frontend and api.
>
> Begin building this system. Do a full search of the codebase to better understand its purpose and layout.

## The Result

After a considerable time the agents finally finished and the frontend, backend, and test harness was created.

```bash
 All 7 tasks are complete. The backend and QA agents are processing their shutdown requests. Here's the final summary
  of everything that was built:

  PPX Platform - Build Complete

  What was built
  ┌──────────┬──────────────────┬───────────────────────────────────────────────────────────────────────────┐
  │  Layer   │      Files       │                              Key Components                               │
  ├──────────┼──────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Backend  │ 49+ Python files │ FastAPI app, 14 REST endpoints, arq worker pipeline, layered architecture │
  ├──────────┼──────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Frontend │ 31+ TS/TSX files │ React 19 + Vite, split-pane viewer, bbox overlays, query navigation       │
  ├──────────┼──────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Tests    │ 9 test files     │ 26/26 passing (handler + route coverage)                                  │
  ├──────────┼──────────────────┼───────────────────────────────────────────────────────────────────────────┤
  │ Docs     │ 2 files          │ architecture.md (1123 lines), qa-report.md (250 lines)                    │
  └──────────┴──────────────────┴───────────────────────────────────────────────────────────────────────────┘
  API Endpoints (14)

  - Document CRUD: upload, list, get, delete
  - Pages: list, image (JPEG), markdown, layout elements
  - Processing: start pipeline, job status, job list
  - Query: semantic search, query history
  - Health check

  Frontend Features

  - Document list with status badges and drag-drop upload
  - Split-pane viewer: page image (left) + Mistral markdown (right)
  - SVG bbox overlays color-coded by element type
  - Query bar with BM25 weight control
  - Result navigation (prev/next) with auto-page switching
  - Processing progress with per-stage tracking
  - Query history dropdown

  QA Results

  - Code review: PASS (2 minor findings, both non-blocking)
  - Tests: 26/26 PASS in 1.58s
  - Frontend build: PASS (zero TypeScript errors, clean Vite build)
  - All acceptance criteria: IMPLEMENTED

● All agents have shut down. Let me clean up the team resources.

● Teammate @qa shut down gracefully

● Team "ppx-platform" cleaned up. All 4 agents (architect, backend, frontend, QA) have completed their work and shut
  down. The PPX Platform is fully built and ready for deployment.
```

When running the platform, due to a number of initial errors found, I needed a few subsequent prompts and some manual fixes. However, all in all it did quite a fantastic job. It followed my design patterns well, used the multi-agent orchestration effectively, and produced a result that was functional (with some elbow grease).

One note is that the agents didn't even attempt to work on the Knowledge Graph implementation I asked them to. This is fairly interesting for two reasons:

1. The feature did not fit the overall theme of the request. That is, to create a web app for the existing backend typr ppx system.
2. I explicitly requested _"Before implementing this feature we will focus on what currently exists in PPX. That is, alignment and basic semantic querying."_ Which Claude likely inferred it as a non-essential requirement.

### Running it
